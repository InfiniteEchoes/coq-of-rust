(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module Fibonacci.
  Record t : Set := {
    curr : u32;
    next : u32;
  }.
  
  Global Instance Get_curr : NamedField.Class t "curr" _ := {|
    NamedField.get '(Build_t x0 _) := x0;
  |}.
  Global Instance Get_next : NamedField.Class t "next" _ := {|
    NamedField.get '(Build_t _ x1) := x1;
  |}.
  Class AssociatedFunction (name : string) (T : Set) : Set := {
    associated_function : T;
  }.
  Arguments associated_function name {T AssociatedFunction}.
End Fibonacci.
Definition Fibonacci : Set := Fibonacci.t.

Module Impl_Iterator_for_Fibonacci.
  Definition Self := Fibonacci.
  
  Definition Item : Set := u32.
  
  Definition next (self : mut_ref Self) : Option :=
    let current := NamedField.get (name := "curr") self in
    assign
      (NamedField.get (name := "curr") self)
      (NamedField.get (name := "next") self) ;;
    assign
      (NamedField.get (name := "next") self)
      (add current (NamedField.get (name := "next") self)) ;;
    Some current.
  
  Global Instance M_next : Method "next" _ := {|
    method := next;
  |}.
  Global Instance AF_next : Fibonacci.AssociatedFunction "next" _ := {|
    Fibonacci.associated_function := next;
  |}.
  Global Instance AFT_next : Iterator.AssociatedFunction "next" _ := {|
    Iterator.associated_function := next;
  |}.
  
  Global Instance I : Iterator.Class Self := {|
    Iterator.Item := Item;
    Iterator.next := next;
  |}.
End Impl_Iterator_for_Fibonacci.

Definition fibonacci (_ : unit) : Fibonacci :=
  {| Fibonacci.curr := 0; Fibonacci.next := 1; |}.

Definition main (_ : unit) : unit :=
  let sequence := {| Range.start := 0; Range.end := 3; |} in
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "Four consecutive `next` calls on 0..3\n" ]
      [  ]) ;;
  tt ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "> "; "\n" ]
      [ _crate.fmt.ImplArgumentV1.new_debug (method "next" sequence) ]) ;;
  tt ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "> "; "\n" ]
      [ _crate.fmt.ImplArgumentV1.new_debug (method "next" sequence) ]) ;;
  tt ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "> "; "\n" ]
      [ _crate.fmt.ImplArgumentV1.new_debug (method "next" sequence) ]) ;;
  tt ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "> "; "\n" ]
      [ _crate.fmt.ImplArgumentV1.new_debug (method "next" sequence) ]) ;;
  tt ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "Iterate through 0..3 using `for`\n" ]
      [  ]) ;;
  tt ;;
  match into_iter {| Range.start := 0; Range.end := 3; |} with
  | iter =>
    loop
      match next iter with
      | None => Break
      | Some {| Some.0 := i; |} =>
        _crate.io._print
          (_crate.fmt.ImplArguments.new_v1
            [ "> "; "\n" ]
            [ _crate.fmt.ImplArgumentV1.new_display i ]) ;;
        tt ;;
        tt
      end ;;
      tt
      from
      for
  end ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "The first four terms of the Fibonacci sequence are: \n" ]
      [  ]) ;;
  tt ;;
  match into_iter (method "take" (fibonacci tt) 4) with
  | iter =>
    loop
      match next iter with
      | None => Break
      | Some {| Some.0 := i; |} =>
        _crate.io._print
          (_crate.fmt.ImplArguments.new_v1
            [ "> "; "\n" ]
            [ _crate.fmt.ImplArgumentV1.new_display i ]) ;;
        tt ;;
        tt
      end ;;
      tt
      from
      for
  end ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "The next four terms of the Fibonacci sequence are: \n" ]
      [  ]) ;;
  tt ;;
  match into_iter (method "take" (method "skip" (fibonacci tt) 4) 4) with
  | iter =>
    loop
      match next iter with
      | None => Break
      | Some {| Some.0 := i; |} =>
        _crate.io._print
          (_crate.fmt.ImplArguments.new_v1
            [ "> "; "\n" ]
            [ _crate.fmt.ImplArgumentV1.new_display i ]) ;;
        tt ;;
        tt
      end ;;
      tt
      from
      for
  end ;;
  let array := [ 1; 3; 3; 7 ] in
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1
      [ "Iterate the following array "; "\n" ]
      [ _crate.fmt.ImplArgumentV1.new_debug array ]) ;;
  tt ;;
  match into_iter (method "iter" array) with
  | iter =>
    loop
      match next iter with
      | None => Break
      | Some {| Some.0 := i; |} =>
        _crate.io._print
          (_crate.fmt.ImplArguments.new_v1
            [ "> "; "\n" ]
            [ _crate.fmt.ImplArgumentV1.new_display i ]) ;;
        tt ;;
        tt
      end ;;
      tt
      from
      for
  end.
