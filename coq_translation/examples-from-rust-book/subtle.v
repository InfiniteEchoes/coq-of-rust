(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.core.prelude.rust_2015.

Module BitAnd := core.ops.BitAnd.

Module BitAndAssign := core.ops.BitAndAssign.

Module BitOr := core.ops.BitOr.

Module BitOrAssign := core.ops.BitOrAssign.

Module BitXor := core.ops.BitXor.

Module BitXorAssign := core.ops.BitXorAssign.

Module Neg := core.ops.Neg.

Module Not := core.ops.Not.

Module Option := core.option.Option.
Definition Option := Option.t.

Module Choice.
  Inductive t : Set := Build (_ : u8).
  
  Global Instance Get_0 : IndexedField.Class t 0 _ := {|
    IndexedField.get '(Build x0) := x0;
  |}.
End Choice.
Definition Choice := Choice.t.

Module Impl__crate_marker_Copy_for_Choice.
  Definition Self := Choice.
  
  Global Instance I : _crate.marker.Copy.Trait Self :=
    _crate.marker.Copy.Build_Class _.
End Impl__crate_marker_Copy_for_Choice.

Module Impl__crate_clone_Clone_for_Choice.
  Definition Self := Choice.
  
  Definition clone (self : ref Self) : Choice :=
    let _ := tt in
    deref self.
  
  Global Instance Method_clone : Notation.Dot "clone" := {|
    Notation.dot := clone;
  |}.
  
  Global Instance I : _crate.clone.Clone.Trait Self := {|
    _crate.clone.Clone.clone := clone;
  |}.
End Impl__crate_clone_Clone_for_Choice.

Module Impl__crate_fmt_Debug_for_Choice.
  Definition Self := Choice.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref _crate.fmt.Formatter)
      : _crate.fmt.Result :=
    _crate.fmt.Formatter::["debug_tuple_field1_finish"]
      f
      "Choice"
      (IndexedField.get (index := 0) self).
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {|
    Notation.dot := fmt;
  |}.
  
  Global Instance I : _crate.fmt.Debug.Trait Self := {|
    _crate.fmt.Debug.fmt := fmt;
  |}.
End Impl__crate_fmt_Debug_for_Choice.

Module ImplChoice.
  Definition Self := Choice.
  
  Definition unwrap_u8 (self : ref Self) : u8 :=
    IndexedField.get (index := 0) self.
  
  Global Instance Method_unwrap_u8 : Notation.Dot "unwrap_u8" := {|
    Notation.dot := unwrap_u8;
  |}.
End ImplChoice.

Module Impl_From_for_bool.
  Definition Self := bool.
  
  Definition from (source : Choice) : bool :=
    if (true : bool) then
      if
        (not
          (bit_or
            (eqb (IndexedField.get (index := 0) source) 0)
            (eqb (IndexedField.get (index := 0) source) 1))
        : bool)
      then
        _crate.panicking.panic
          "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)"
      else
        tt ;;
      tt
    else
      tt ;;
    ne (IndexedField.get (index := 0) source) 0.
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {|
    Notation.double_colon := from;
  |}.
  
  Global Instance I : From.Trait Choice Self := {|
    From.from := from;
  |}.
End Impl_From_for_bool.

Module Impl_BitAnd_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition bitand (self : Self) (rhs : Choice) : Choice :=
    (bit_and
        (IndexedField.get (index := 0) self)
        (IndexedField.get (index := 0) rhs)).["into"].
  
  Global Instance Method_bitand : Notation.Dot "bitand" := {|
    Notation.dot := bitand;
  |}.
  
  Global Instance I : BitAnd.Trait Self := {|
    BitAnd.Output := Output;
    BitAnd.bitand := bitand;
  |}.
End Impl_BitAnd_for_Choice.

Module Impl_BitAndAssign_for_Choice.
  Definition Self := Choice.
  
  Definition bitand_assign (self : mut_ref Self) (rhs : Choice) :=
    assign (deref self) (bit_and (deref self) rhs) ;;
    tt.
  
  Global Instance Method_bitand_assign : Notation.Dot "bitand_assign" := {|
    Notation.dot := bitand_assign;
  |}.
  
  Global Instance I : BitAndAssign.Trait Self := {|
    BitAndAssign.bitand_assign := bitand_assign;
  |}.
End Impl_BitAndAssign_for_Choice.

Module Impl_BitOr_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition bitor (self : Self) (rhs : Choice) : Choice :=
    (bit_or
        (IndexedField.get (index := 0) self)
        (IndexedField.get (index := 0) rhs)).["into"].
  
  Global Instance Method_bitor : Notation.Dot "bitor" := {|
    Notation.dot := bitor;
  |}.
  
  Global Instance I : BitOr.Trait Self := {|
    BitOr.Output := Output;
    BitOr.bitor := bitor;
  |}.
End Impl_BitOr_for_Choice.

Module Impl_BitOrAssign_for_Choice.
  Definition Self := Choice.
  
  Definition bitor_assign (self : mut_ref Self) (rhs : Choice) :=
    assign (deref self) (bit_or (deref self) rhs) ;;
    tt.
  
  Global Instance Method_bitor_assign : Notation.Dot "bitor_assign" := {|
    Notation.dot := bitor_assign;
  |}.
  
  Global Instance I : BitOrAssign.Trait Self := {|
    BitOrAssign.bitor_assign := bitor_assign;
  |}.
End Impl_BitOrAssign_for_Choice.

Module Impl_BitXor_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition bitxor (self : Self) (rhs : Choice) : Choice :=
    (bit_xor
        (IndexedField.get (index := 0) self)
        (IndexedField.get (index := 0) rhs)).["into"].
  
  Global Instance Method_bitxor : Notation.Dot "bitxor" := {|
    Notation.dot := bitxor;
  |}.
  
  Global Instance I : BitXor.Trait Self := {|
    BitXor.Output := Output;
    BitXor.bitxor := bitxor;
  |}.
End Impl_BitXor_for_Choice.

Module Impl_BitXorAssign_for_Choice.
  Definition Self := Choice.
  
  Definition bitxor_assign (self : mut_ref Self) (rhs : Choice) :=
    assign (deref self) (bit_xor (deref self) rhs) ;;
    tt.
  
  Global Instance Method_bitxor_assign : Notation.Dot "bitxor_assign" := {|
    Notation.dot := bitxor_assign;
  |}.
  
  Global Instance I : BitXorAssign.Trait Self := {|
    BitXorAssign.bitxor_assign := bitxor_assign;
  |}.
End Impl_BitXorAssign_for_Choice.

Module Impl_Not_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition not (self : Self) : Choice :=
    (bit_and 1 (not (IndexedField.get (index := 0) self))).["into"].
  
  Global Instance Method_not : Notation.Dot "not" := {|
    Notation.dot := not;
  |}.
  
  Global Instance I : Not.Trait Self := {|
    Not.Output := Output;
    Not.not := not;
  |}.
End Impl_Not_for_Choice.

Definition black_box (input : u8) : u8 :=
  if (true : bool) then
    if (not (bit_or (eqb input 0) (eqb input 1)) : bool) then
      _crate.panicking.panic "assertion failed: (input == 0u8) | (input == 1u8)"
    else
      tt ;;
    tt
  else
    tt ;;
  core.ptr.read_volatile (cast input (ref u8)).

Module Impl_From_for_Choice.
  Definition Self := Choice.
  
  Definition from (input : u8) : Choice := Choice.Build (black_box input).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {|
    Notation.double_colon := from;
  |}.
  
  Global Instance I : From.Trait u8 Self := {|
    From.from := from;
  |}.
End Impl_From_for_Choice.

Module ConstantTimeEq.
  Class Trait (Self : Set) : Set := {
    ct_eq : (ref Self) -> ((ref Self) -> Choice);
  }.
  
  Global Instance Method_ct_eq `(Trait) : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  Global Instance Method_ct_ne `(Trait) : Notation.Dot "ct_ne" := {|
    Notation.dot (self : ref Self) (other : ref Self) :=
      (not (self.["ct_eq"] other)
      : Choice);
  |}.
End ConstantTimeEq.

Module Impl_ConstantTimeEq_for_Slice.
  Definition Self := Slice.
  
  Definition ct_eq (self : ref Self) (_rhs : ref Slice) : Choice :=
    let len := self.["len"] in
    if (ne len _rhs.["len"] : bool) then
      Return (Choice::["from"] 0) ;;
      tt
    else
      tt ;;
    let x := 1 in
    match LangItem (self.["iter"].["zip"] _rhs.["iter"]) with
    | iter =>
      loop
        match LangItem iter with
        | None => Break
        | Some {| Some.0 := (ai, bi); |} =>
          assign x (bit_and x (ai.["ct_eq"] bi).["unwrap_u8"]) ;;
          tt
        end ;;
        tt
        from
        for
    end ;;
    x.["into"].
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I T : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_Slice.

Module Impl_ConstantTimeEq_for_Choice.
  Definition Self := Choice.
  
  Definition ct_eq (self : ref Self) (rhs : ref Choice) : Choice :=
    not (bit_xor (deref self) (deref rhs)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_Choice.

Module Impl_ConstantTimeEq_for_u8.
  Definition Self := u8.
  
  Definition ct_eq (self : ref Self) (other : ref u8) : Choice :=
    let x := bit_xor self other in
    let y := shr (bit_or x x.["wrapping_neg"]) (sub 8 1) in
    (cast (bit_xor y (cast 1 u8)) u8).["into"].
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_u8.

Module Impl_ConstantTimeEq_for_i8.
  Definition Self := i8.
  
  Definition ct_eq (self : ref Self) (other : ref i8) : Choice :=
    (cast (deref self) u8).["ct_eq"] (cast (deref other) u8).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_i8.

Module Impl_ConstantTimeEq_for_u16.
  Definition Self := u16.
  
  Definition ct_eq (self : ref Self) (other : ref u16) : Choice :=
    let x := bit_xor self other in
    let y := shr (bit_or x x.["wrapping_neg"]) (sub 16 1) in
    (cast (bit_xor y (cast 1 u16)) u8).["into"].
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_u16.

Module Impl_ConstantTimeEq_for_i16.
  Definition Self := i16.
  
  Definition ct_eq (self : ref Self) (other : ref i16) : Choice :=
    (cast (deref self) u16).["ct_eq"] (cast (deref other) u16).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_i16.

Module Impl_ConstantTimeEq_for_u32.
  Definition Self := u32.
  
  Definition ct_eq (self : ref Self) (other : ref u32) : Choice :=
    let x := bit_xor self other in
    let y := shr (bit_or x x.["wrapping_neg"]) (sub 32 1) in
    (cast (bit_xor y (cast 1 u32)) u8).["into"].
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_u32.

Module Impl_ConstantTimeEq_for_i32.
  Definition Self := i32.
  
  Definition ct_eq (self : ref Self) (other : ref i32) : Choice :=
    (cast (deref self) u32).["ct_eq"] (cast (deref other) u32).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_i32.

Module Impl_ConstantTimeEq_for_u64.
  Definition Self := u64.
  
  Definition ct_eq (self : ref Self) (other : ref u64) : Choice :=
    let x := bit_xor self other in
    let y := shr (bit_or x x.["wrapping_neg"]) (sub 64 1) in
    (cast (bit_xor y (cast 1 u64)) u8).["into"].
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_u64.

Module Impl_ConstantTimeEq_for_i64.
  Definition Self := i64.
  
  Definition ct_eq (self : ref Self) (other : ref i64) : Choice :=
    (cast (deref self) u64).["ct_eq"] (cast (deref other) u64).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_i64.

Module Impl_ConstantTimeEq_for_usize.
  Definition Self := usize.
  
  Definition ct_eq (self : ref Self) (other : ref usize) : Choice :=
    let x := bit_xor self other in
    let y :=
      shr
        (bit_or x x.["wrapping_neg"])
        (sub (mul (Root.core.mem.size_of tt) 8) 1) in
    (cast (bit_xor y (cast 1 usize)) u8).["into"].
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_usize.

Module Impl_ConstantTimeEq_for_isize.
  Definition Self := isize.
  
  Definition ct_eq (self : ref Self) (other : ref isize) : Choice :=
    (cast (deref self) usize).["ct_eq"] (cast (deref other) usize).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_isize.

Module ConditionallySelectable.
  Class Trait (Self : Set) : Set := {
    conditional_select : (ref Self) -> ((ref Self) -> (Choice -> Self));
  }.
  
  Global Instance Method_conditional_select `(Trait)
    : Notation.Dot "conditional_select" := {|
    Notation.dot := conditional_select;
  |}.
  Global Instance Method_conditional_assign `(Trait)
    : Notation.Dot "conditional_assign" := {|
    Notation.dot (self : mut_ref Self) (other : ref Self) (choice : Choice) :=
      (assign (deref self) (Self::["conditional_select"] self other choice) ;;
      tt
      : unit);
  |}.
  Global Instance Method_conditional_swap `(Trait)
    : Notation.Dot "conditional_swap" := {|
    Notation.dot (a : mut_ref Self) (b : mut_ref Self) (choice : Choice) :=
      (let t := deref a in
      a.["conditional_assign"] b choice ;;
      b.["conditional_assign"] t choice ;;
      tt
      : unit);
  |}.
End ConditionallySelectable.

Module Impl_ConditionallySelectable_for_u8.
  Definition Self := u8.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i8)) u8 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i8)) u8 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i8)) u8 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_u8.

Module Impl_ConditionallySelectable_for_i8.
  Definition Self := i8.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i8)) i8 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i8)) i8 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i8)) i8 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_i8.

Module Impl_ConditionallySelectable_for_u16.
  Definition Self := u16.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i16)) u16 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i16)) u16 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i16)) u16 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_u16.

Module Impl_ConditionallySelectable_for_i16.
  Definition Self := i16.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i16)) i16 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i16)) i16 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i16)) i16 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_i16.

Module Impl_ConditionallySelectable_for_u32.
  Definition Self := u32.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i32)) u32 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i32)) u32 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i32)) u32 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_u32.

Module Impl_ConditionallySelectable_for_i32.
  Definition Self := i32.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i32)) i32 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i32)) i32 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i32)) i32 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_i32.

Module Impl_ConditionallySelectable_for_u64.
  Definition Self := u64.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i64)) u64 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i64)) u64 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i64)) u64 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_u64.

Module Impl_ConditionallySelectable_for_i64.
  Definition Self := i64.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i64)) i64 in
    bit_xor a (bit_and mask (bit_xor a b)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i64)) i64 in
    assign
      (deref self)
      (bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other)))) ;;
    tt.
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {|
    Notation.dot := conditional_assign;
  |}.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    let mask := cast (neg (cast choice.["unwrap_u8"] i64)) i64 in
    let t := bit_and mask (bit_xor (deref a) (deref b)) in
    assign (deref a) (bit_xor (deref a) t) ;;
    assign (deref b) (bit_xor (deref b) t) ;;
    tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {|
    Notation.double_colon := conditional_swap;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_i64.

Module Impl_ConditionallySelectable_for_Choice.
  Definition Self := Choice.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    Choice.Build
      (u8::["conditional_select"]
        (IndexedField.get (index := 0) a)
        (IndexedField.get (index := 0) b)
        choice).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Global Instance I : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_Choice.

Module ConditionallyNegatable.
  Class Trait (Self : Set) : Set := {
    conditional_negate : (mut_ref Self) -> (Choice -> _);
  }.
  
  Global Instance Method_conditional_negate `(Trait)
    : Notation.Dot "conditional_negate" := {|
    Notation.dot := conditional_negate;
  |}.
End ConditionallyNegatable.

Module Impl_ConditionallyNegatable_for_T.
  Definition Self := T.
  
  Definition conditional_negate (self : mut_ref Self) (choice : Choice) :=
    let self_neg := neg (cast self (ref T)) in
    self.["conditional_assign"] self_neg choice ;;
    tt.
  
  Global Instance Method_conditional_negate :
    Notation.Dot "conditional_negate" := {|
    Notation.dot := conditional_negate;
  |}.
  
  Global Instance I T : ConditionallyNegatable.Trait Self := {|
    ConditionallyNegatable.conditional_negate := conditional_negate;
  |}.
End Impl_ConditionallyNegatable_for_T.

Module CtOption.
  Record t : Set := {
    value : T;
    is_some : Choice;
  }.
  
  Global Instance Get_value : Notation.Dot "value" := {|
    Notation.dot '(Build_t x0 _) := x0;
  |}.
  Global Instance Get_is_some : Notation.Dot "is_some" := {|
    Notation.dot '(Build_t _ x1) := x1;
  |}.
End CtOption.
Definition CtOption : Set := CtOption.t.

Module Impl__crate_clone_Clone_for_CtOption.
  Definition Self := CtOption.
  
  Definition clone (self : ref Self) : CtOption :=
    {|
      CtOption.value := _crate.clone.Clone.clone self.["value"];
      CtOption.is_some := _crate.clone.Clone.clone self.["is_some"];
    |}.
  
  Global Instance Method_clone : Notation.Dot "clone" := {|
    Notation.dot := clone;
  |}.
  
  Global Instance I T : _crate.clone.Clone.Trait Self := {|
    _crate.clone.Clone.clone := clone;
  |}.
End Impl__crate_clone_Clone_for_CtOption.

Module Impl__crate_marker_Copy_for_CtOption.
  Definition Self := CtOption.
  
  Global Instance I T : _crate.marker.Copy.Trait Self :=
    _crate.marker.Copy.Build_Class _.
End Impl__crate_marker_Copy_for_CtOption.

Module Impl__crate_fmt_Debug_for_CtOption.
  Definition Self := CtOption.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref _crate.fmt.Formatter)
      : _crate.fmt.Result :=
    _crate.fmt.Formatter::["debug_struct_field2_finish"]
      f
      "CtOption"
      "value"
      self.["value"]
      "is_some"
      self.["is_some"].
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {|
    Notation.dot := fmt;
  |}.
  
  Global Instance I T : _crate.fmt.Debug.Trait Self := {|
    _crate.fmt.Debug.fmt := fmt;
  |}.
End Impl__crate_fmt_Debug_for_CtOption.

Module Impl_From_for_Option.
  Definition Self := Option.
  
  Definition from (source : CtOption) : Option :=
    if (eqb source.["is_some"].["unwrap_u8"] 1 : bool) then
      Option.Some source.["value"]
    else
      None.
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {|
    Notation.double_colon := from;
  |}.
  
  Global Instance I T : From.Trait CtOption Self := {|
    From.from := from;
  |}.
End Impl_From_for_Option.

Module ImplCtOption.
  Definition Self := CtOption.
  
  Definition new (value : T) (is_some : Choice) : CtOption :=
    {| CtOption.value := value; CtOption.is_some := is_some; |}.
  
  Global Instance AssociatedFunction_new : Notation.DoubleColon Self "new" := {|
    Notation.double_colon := new;
  |}.
  
  Definition expect (self : Self) (msg : ref str) : T :=
    match (self.["is_some"].["unwrap_u8"], 1) with
    | (left_val, right_val) =>
      if (not (eqb (deref left_val) (deref right_val)) : bool) then
        let kind := _crate.panicking.AssertKind.Eq in
        _crate.panicking.assert_failed
          kind
          (deref left_val)
          (deref right_val)
          (_crate.option.Option.Some
            (_crate.fmt.Arguments::["new_v1"]
              [ "" ]
              [ _crate.fmt.ArgumentV1::["new_display"] msg ])) ;;
        tt
      else
        tt
    end ;;
    self.["value"].
  
  Global Instance Method_expect : Notation.Dot "expect" := {|
    Notation.dot := expect;
  |}.
  
  Definition unwrap (self : Self) : T :=
    match (self.["is_some"].["unwrap_u8"], 1) with
    | (left_val, right_val) =>
      if (not (eqb (deref left_val) (deref right_val)) : bool) then
        let kind := _crate.panicking.AssertKind.Eq in
        _crate.panicking.assert_failed
          kind
          (deref left_val)
          (deref right_val)
          _crate.option.Option.None ;;
        tt
      else
        tt
    end ;;
    self.["value"].
  
  Global Instance Method_unwrap : Notation.Dot "unwrap" := {|
    Notation.dot := unwrap;
  |}.
  
  Definition unwrap_or (self : Self) (def : T) : T :=
    T::["conditional_select"] def self.["value"] self.["is_some"].
  
  Global Instance Method_unwrap_or : Notation.Dot "unwrap_or" := {|
    Notation.dot := unwrap_or;
  |}.
  
  Definition unwrap_or_else (self : Self) (f : F) : T :=
    T::["conditional_select"] (f tt) self.["value"] self.["is_some"].
  
  Global Instance Method_unwrap_or_else : Notation.Dot "unwrap_or_else" := {|
    Notation.dot := unwrap_or_else;
  |}.
  
  Definition is_some (self : ref Self) : Choice := self.["is_some"].
  
  Global Instance Method_is_some : Notation.Dot "is_some" := {|
    Notation.dot := is_some;
  |}.
  
  Definition is_none (self : ref Self) : Choice := not self.["is_some"].
  
  Global Instance Method_is_none : Notation.Dot "is_none" := {|
    Notation.dot := is_none;
  |}.
  
  Definition map (self : Self) (f : F) : CtOption :=
    CtOption::["new"]
      (f
        (T::["conditional_select"]
          (T::["default"] tt)
          self.["value"]
          self.["is_some"]))
      self.["is_some"].
  
  Global Instance Method_map : Notation.Dot "map" := {|
    Notation.dot := map;
  |}.
  
  Definition and_then (self : Self) (f : F) : CtOption :=
    let tmp :=
      f
        (T::["conditional_select"]
          (T::["default"] tt)
          self.["value"]
          self.["is_some"]) in
    assign tmp.["is_some"] (bit_and tmp.["is_some"] self.["is_some"]) ;;
    tmp.
  
  Global Instance Method_and_then : Notation.Dot "and_then" := {|
    Notation.dot := and_then;
  |}.
  
  Definition or_else (self : Self) (f : F) : CtOption :=
    let is_none := self.["is_none"] in
    let f := f tt in
    Self::["conditional_select"] self f is_none.
  
  Global Instance Method_or_else : Notation.Dot "or_else" := {|
    Notation.dot := or_else;
  |}.
End ImplCtOption.

Module Impl_ConditionallySelectable_for_CtOption.
  Definition Self := CtOption.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice)
      : Self :=
    CtOption::["new"]
      (T::["conditional_select"] a.["value"] b.["value"] choice)
      (Choice::["conditional_select"] a.["is_some"] b.["is_some"] choice).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {|
    Notation.double_colon := conditional_select;
  |}.
  
  Global Instance I T : ConditionallySelectable.Trait Self := {|
    ConditionallySelectable.conditional_select := conditional_select;
  |}.
End Impl_ConditionallySelectable_for_CtOption.

Module Impl_ConstantTimeEq_for_CtOption.
  Definition Self := CtOption.
  
  Definition ct_eq (self : ref Self) (rhs : ref CtOption) : Choice :=
    let a := self.["is_some"] in
    let b := rhs.["is_some"] in
    bit_or
      (bit_and (bit_and a b) (self.["value"].["ct_eq"] rhs.["value"]))
      (bit_and (not a) (not b)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {|
    Notation.dot := ct_eq;
  |}.
  
  Global Instance I T : ConstantTimeEq.Trait Self := {|
    ConstantTimeEq.ct_eq := ct_eq;
  |}.
End Impl_ConstantTimeEq_for_CtOption.

Module ConstantTimeGreater.
  Class Trait (Self : Set) : Set := {
    ct_gt : (ref Self) -> ((ref Self) -> Choice);
  }.
  
  Global Instance Method_ct_gt `(Trait) : Notation.Dot "ct_gt" := {|
    Notation.dot := ct_gt;
  |}.
End ConstantTimeGreater.

Module Impl_ConstantTimeGreater_for_u8.
  Definition Self := u8.
  
  Definition ct_gt (self : ref Self) (other : ref u8) : Choice :=
    let gtb := bit_and self (not other) in
    let ltb := bit_and (not self) other in
    let pow := 1 in
    loop
      (if (lt pow 8 : bool) then
        assign ltb (bit_or ltb (shr ltb pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    let bit := bit_and gtb (not ltb) in
    let pow := 1 in
    loop
      (if (lt pow 8 : bool) then
        assign bit (bit_or bit (shr bit pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    Choice::["from"] (cast (bit_and bit 1) u8).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {|
    Notation.dot := ct_gt;
  |}.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {|
    ConstantTimeGreater.ct_gt := ct_gt;
  |}.
End Impl_ConstantTimeGreater_for_u8.

Module Impl_ConstantTimeGreater_for_u16.
  Definition Self := u16.
  
  Definition ct_gt (self : ref Self) (other : ref u16) : Choice :=
    let gtb := bit_and self (not other) in
    let ltb := bit_and (not self) other in
    let pow := 1 in
    loop
      (if (lt pow 16 : bool) then
        assign ltb (bit_or ltb (shr ltb pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    let bit := bit_and gtb (not ltb) in
    let pow := 1 in
    loop
      (if (lt pow 16 : bool) then
        assign bit (bit_or bit (shr bit pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    Choice::["from"] (cast (bit_and bit 1) u8).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {|
    Notation.dot := ct_gt;
  |}.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {|
    ConstantTimeGreater.ct_gt := ct_gt;
  |}.
End Impl_ConstantTimeGreater_for_u16.

Module Impl_ConstantTimeGreater_for_u32.
  Definition Self := u32.
  
  Definition ct_gt (self : ref Self) (other : ref u32) : Choice :=
    let gtb := bit_and self (not other) in
    let ltb := bit_and (not self) other in
    let pow := 1 in
    loop
      (if (lt pow 32 : bool) then
        assign ltb (bit_or ltb (shr ltb pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    let bit := bit_and gtb (not ltb) in
    let pow := 1 in
    loop
      (if (lt pow 32 : bool) then
        assign bit (bit_or bit (shr bit pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    Choice::["from"] (cast (bit_and bit 1) u8).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {|
    Notation.dot := ct_gt;
  |}.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {|
    ConstantTimeGreater.ct_gt := ct_gt;
  |}.
End Impl_ConstantTimeGreater_for_u32.

Module Impl_ConstantTimeGreater_for_u64.
  Definition Self := u64.
  
  Definition ct_gt (self : ref Self) (other : ref u64) : Choice :=
    let gtb := bit_and self (not other) in
    let ltb := bit_and (not self) other in
    let pow := 1 in
    loop
      (if (lt pow 64 : bool) then
        assign ltb (bit_or ltb (shr ltb pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    let bit := bit_and gtb (not ltb) in
    let pow := 1 in
    loop
      (if (lt pow 64 : bool) then
        assign bit (bit_or bit (shr bit pow)) ;;
        assign pow (add pow pow) ;;
        tt
      else
        Break ;;
        tt)
      from
      while ;;
    Choice::["from"] (cast (bit_and bit 1) u8).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {|
    Notation.dot := ct_gt;
  |}.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {|
    ConstantTimeGreater.ct_gt := ct_gt;
  |}.
End Impl_ConstantTimeGreater_for_u64.

Module ConstantTimeLess.
  Class Trait (Self : Set) : Set := {
  }.
  
  Global Instance Method_ct_lt `(Trait) : Notation.Dot "ct_lt" := {|
    Notation.dot (self : ref Self) (other : ref Self) :=
      (bit_and (not (self.["ct_gt"] other)) (not (self.["ct_eq"] other))
      : Choice);
  |}.
End ConstantTimeLess.

Module Impl_ConstantTimeLess_for_u8.
  Definition Self := u8.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u8.

Module Impl_ConstantTimeLess_for_u16.
  Definition Self := u16.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u16.

Module Impl_ConstantTimeLess_for_u32.
  Definition Self := u32.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u32.

Module Impl_ConstantTimeLess_for_u64.
  Definition Self := u64.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u64.
