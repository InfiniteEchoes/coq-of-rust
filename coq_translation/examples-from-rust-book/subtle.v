(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Definition Choice : Set :=
  u8.

Module Impl__crate_marker_Copy_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : _crate.marker.Copy.Class Self := {|
  |}.
Module ImplChoice.

Module Impl__crate_clone_Clone_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : _crate.clone.Clone.Class Self := {|
    clone
      (self : static_ref Choice)
      :=
      let _ := tt in
      deref self;
  |}.
Module ImplChoice.

Module Impl__crate_fmt_Debug_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : _crate.fmt.Debug.Class Self := {|
    fmt
      (self : static_ref Choice)
      (f : mut_ref _crate.fmt.Formatter)
      :=
      _crate::fmt::ImplFormatter.debug_tuple_field1_finish f "Choice" self.0;
  |}.
Module ImplChoice.

(* Impl [Choice] *)
Module ImplChoice.
  Definition unwrap_u8 (self : static_ref Choice) : u8 :=
    self.0.
End ImplChoice.
(* End impl [Choice] *)

Module Impl_From_for_bool.
  Definition Self := bool.
  
  #[global] Instance I : From.Class Self := {|
    from
      (source : Choice)
      :=
      if true then
        if not (bit_or (eq source.0 0) (eq source.0 1)) then
          _crate.panicking.panic
            "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)"
        else
          tt ;;
        tt
      else
        tt ;;
      ne source.0 0;
  |}.
Module Implbool.

Module Impl_BitAnd_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : BitAnd.Class Self := {|
    Output := Choice;
    bitand (self : Choice) (rhs : Choice) := into (bit_and self.0 rhs.0);
  |}.
Module ImplChoice.

Module Impl_BitAndAssign_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : BitAndAssign.Class Self := {|
    bitand_assign
      (self : mut_ref Choice)
      (rhs : Choice)
      :=
      assign deref self := bit_and (deref self) rhs ;;
      tt;
  |}.
Module ImplChoice.

Module Impl_BitOr_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : BitOr.Class Self := {|
    Output := Choice;
    bitor (self : Choice) (rhs : Choice) := into (bit_or self.0 rhs.0);
  |}.
Module ImplChoice.

Module Impl_BitOrAssign_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : BitOrAssign.Class Self := {|
    bitor_assign
      (self : mut_ref Choice)
      (rhs : Choice)
      :=
      assign deref self := bit_or (deref self) rhs ;;
      tt;
  |}.
Module ImplChoice.

Module Impl_BitXor_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : BitXor.Class Self := {|
    Output := Choice;
    bitxor (self : Choice) (rhs : Choice) := into (bit_xor self.0 rhs.0);
  |}.
Module ImplChoice.

Module Impl_BitXorAssign_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : BitXorAssign.Class Self := {|
    bitxor_assign
      (self : mut_ref Choice)
      (rhs : Choice)
      :=
      assign deref self := bit_xor (deref self) rhs ;;
      tt;
  |}.
Module ImplChoice.

Module Impl_Not_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : Not.Class Self := {|
    Output := Choice;
    not (self : Choice) := into (bit_and 1 (not self.0));
  |}.
Module ImplChoice.

Definition black_box (_ : unit) :=
  if true then
    if not (bit_or (eq input 0) (eq input 1)) then
      _crate.panicking.panic "assertion failed: (input == 0u8) | (input == 1u8)"
    else
      tt ;;
    tt
  else
    tt ;;
  core.ptr.read_volatile input.

Module Impl_From_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : From.Class Self := {|
    from (input : u8) := Choice (black_box input);
  |}.
Module ImplChoice.

Class ConstantTimeEq : Set := {
  ct_eq : static_ref Self -> static_ref Self -> Choice;
  ct_ne : static_ref Self -> static_ref Self -> Choice;
}.

Module Impl_ConstantTimeEq_for_Slice.
  Definition Self := Slice.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref [T])
      (_rhs : static_ref Slice)
      :=
      let len := len self in
      if ne len (len _rhs) then
        Return (ImplChoice.from 0) ;;
        tt
      else
        tt ;;
      let x := 1 in
      match into_iter (zip (iter self) (iter _rhs)) with
      | iter =>
        loop match next iter with
        | {|  |} => Break
        | {| Some.0 := (ai, bi); |} =>
          assign x := bit_and x (unwrap_u8 (ct_eq ai bi)) ;;
          tt
        end ;;
        tt from for
      end ;;
      into x;
  |}.
Module ImplSlice.

Module Impl_ConstantTimeEq_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref Choice)
      (rhs : static_ref Choice)
      :=
      not (bit_xor (deref self) (deref rhs));
  |}.
Module ImplChoice.

Module Impl_ConstantTimeEq_for_u8.
  Definition Self := u8.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref u8)
      (other : static_ref u8)
      :=
      let x := bit_xor self other in
      let y := shr (bit_or x (wrapping_neg x)) (sub 8 1) in
      into (bit_xor y 1);
  |}.
Module Implu8.

Module Impl_ConstantTimeEq_for_i8.
  Definition Self := i8.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref i8)
      (other : static_ref i8)
      :=
      ct_eq (deref self) (deref other);
  |}.
Module Impli8.

Module Impl_ConstantTimeEq_for_u16.
  Definition Self := u16.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref u16)
      (other : static_ref u16)
      :=
      let x := bit_xor self other in
      let y := shr (bit_or x (wrapping_neg x)) (sub 16 1) in
      into (bit_xor y 1);
  |}.
Module Implu16.

Module Impl_ConstantTimeEq_for_i16.
  Definition Self := i16.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref i16)
      (other : static_ref i16)
      :=
      ct_eq (deref self) (deref other);
  |}.
Module Impli16.

Module Impl_ConstantTimeEq_for_u32.
  Definition Self := u32.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref u32)
      (other : static_ref u32)
      :=
      let x := bit_xor self other in
      let y := shr (bit_or x (wrapping_neg x)) (sub 32 1) in
      into (bit_xor y 1);
  |}.
Module Implu32.

Module Impl_ConstantTimeEq_for_i32.
  Definition Self := i32.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref i32)
      (other : static_ref i32)
      :=
      ct_eq (deref self) (deref other);
  |}.
Module Impli32.

Module Impl_ConstantTimeEq_for_u64.
  Definition Self := u64.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref u64)
      (other : static_ref u64)
      :=
      let x := bit_xor self other in
      let y := shr (bit_or x (wrapping_neg x)) (sub 64 1) in
      into (bit_xor y 1);
  |}.
Module Implu64.

Module Impl_ConstantTimeEq_for_i64.
  Definition Self := i64.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref i64)
      (other : static_ref i64)
      :=
      ct_eq (deref self) (deref other);
  |}.
Module Impli64.

Module Impl_ConstantTimeEq_for_usize.
  Definition Self := usize.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref usize)
      (other : static_ref usize)
      :=
      let x := bit_xor self other in
      let y := shr
        (bit_or x (wrapping_neg x))
        (sub (mul ({{root}}.core.mem.size_of tt) 8) 1) in
      into (bit_xor y 1);
  |}.
Module Implusize.

Module Impl_ConstantTimeEq_for_isize.
  Definition Self := isize.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref isize)
      (other : static_ref isize)
      :=
      ct_eq (deref self) (deref other);
  |}.
Module Implisize.

Class ConditionallySelectable : Set := {
  conditional_select : static_ref Self -> static_ref Self -> Choice -> Self;
  conditional_assign : mut_ref Self -> static_ref Self -> Choice -> _;
  conditional_swap : mut_ref Self -> mut_ref Self -> Choice -> _;
}.

Module Impl_ConditionallySelectable_for_u8.
  Definition Self := u8.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref u8)
      (b : static_ref u8)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref u8)
      (other : static_ref u8)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref u8)
      (b : mut_ref u8)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Implu8.

Module Impl_ConditionallySelectable_for_i8.
  Definition Self := i8.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref i8)
      (b : static_ref i8)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref i8)
      (other : static_ref i8)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref i8)
      (b : mut_ref i8)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Impli8.

Module Impl_ConditionallySelectable_for_u16.
  Definition Self := u16.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref u16)
      (b : static_ref u16)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref u16)
      (other : static_ref u16)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref u16)
      (b : mut_ref u16)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Implu16.

Module Impl_ConditionallySelectable_for_i16.
  Definition Self := i16.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref i16)
      (b : static_ref i16)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref i16)
      (other : static_ref i16)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref i16)
      (b : mut_ref i16)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Impli16.

Module Impl_ConditionallySelectable_for_u32.
  Definition Self := u32.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref u32)
      (b : static_ref u32)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref u32)
      (other : static_ref u32)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref u32)
      (b : mut_ref u32)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Implu32.

Module Impl_ConditionallySelectable_for_i32.
  Definition Self := i32.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref i32)
      (b : static_ref i32)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref i32)
      (other : static_ref i32)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref i32)
      (b : mut_ref i32)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Impli32.

Module Impl_ConditionallySelectable_for_u64.
  Definition Self := u64.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref u64)
      (b : static_ref u64)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref u64)
      (other : static_ref u64)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref u64)
      (b : mut_ref u64)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Implu64.

Module Impl_ConditionallySelectable_for_i64.
  Definition Self := i64.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref i64)
      (b : static_ref i64)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      bit_xor a (bit_and mask (bit_xor a b));
    conditional_assign
      (self : mut_ref i64)
      (other : static_ref i64)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      assign deref self := bit_xor
        (deref self)
        (bit_and mask (bit_xor (deref self) (deref other))) ;;
      tt;
    conditional_swap
      (a : mut_ref i64)
      (b : mut_ref i64)
      (choice : Choice)
      :=
      let mask := neg (unwrap_u8 choice) in
      let t := bit_and mask (bit_xor (deref a) (deref b)) in
      assign deref a := bit_xor (deref a) t ;;
      assign deref b := bit_xor (deref b) t ;;
      tt;
  |}.
Module Impli64.

Module Impl_ConditionallySelectable_for_Choice.
  Definition Self := Choice.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref Choice)
      (b : static_ref Choice)
      (choice : Choice)
      :=
      Choice (Implu8.conditional_select a.0 b.0 choice);
  |}.
Module ImplChoice.

Class ConditionallyNegatable : Set := {
  conditional_negate : mut_ref Self -> Choice -> _;
}.

Module Impl_ConditionallyNegatable_for_T.
  Definition Self := T.
  
  #[global] Instance I : ConditionallyNegatable.Class Self := {|
    conditional_negate
      (self : mut_ref T)
      (choice : Choice)
      :=
      let self_neg := neg self in
      conditional_assign self self_neg choice ;;
      tt;
  |}.
Module ImplT.

Module CtOption.
  Record t : Set := {
    value : T;
    is_some : Choice;
  }.
End CtOption.
Definition CtOption : Set := CtOption.t.

Module Impl__crate_clone_Clone_for_CtOption.
  Definition Self := CtOption.
  
  #[global] Instance I : _crate.clone.Clone.Class Self := {|
    clone
      (self : static_ref CtOption<T>)
      :=
      {|
        CtOption.value := _crate.clone.Clone.clone self.value;
        CtOption.is_some := _crate.clone.Clone.clone self.is_some;
      |};
  |}.
Module ImplCtOption.

Module Impl__crate_marker_Copy_for_CtOption.
  Definition Self := CtOption.
  
  #[global] Instance I : _crate.marker.Copy.Class Self := {|
  |}.
Module ImplCtOption.

Module Impl__crate_fmt_Debug_for_CtOption.
  Definition Self := CtOption.
  
  #[global] Instance I : _crate.fmt.Debug.Class Self := {|
    fmt
      (self : static_ref CtOption<T>)
      (f : mut_ref _crate.fmt.Formatter)
      :=
      _crate::fmt::ImplFormatter.debug_struct_field2_finish
        f
        "CtOption"
        "value"
        self.value
        "is_some"
        self.is_some;
  |}.
Module ImplCtOption.

Module Impl_From_for_Option.
  Definition Self := Option.
  
  #[global] Instance I : From.Class Self := {|
    from
      (source : CtOption)
      :=
      if eq (unwrap_u8 (is_some source)) 1 then
        Option.Some source.value
      else
        None;
  |}.
Module ImplOption.

(* Impl [CtOption] *)
Module ImplCtOption.
  Definition new (value : T) (is_some : Choice) : CtOption :=
    {| CtOption.value := value; CtOption.is_some := is_some; |}.
  
  Definition expect (self : CtOption<T>) (msg : static_ref str) : T :=
    match (unwrap_u8 self.is_some, 1) with
    | (left_val, right_val) =>
      if not (eq (deref left_val) (deref right_val)) then
        let kind := _crate.panicking.AssertKind.Eq in
        _crate.panicking.assert_failed
          kind
          (deref left_val)
          (deref right_val)
          (_crate.option.Option.Some
            (_crate::fmt::ImplArguments.new_v1
              [""]
              [_crate::fmt::ImplArgumentV1.new_display msg])) ;;
        tt
      else
        tt
    end ;;
    self.value.
  
  Definition unwrap (self : CtOption<T>) : T :=
    match (unwrap_u8 self.is_some, 1) with
    | (left_val, right_val) =>
      if not (eq (deref left_val) (deref right_val)) then
        let kind := _crate.panicking.AssertKind.Eq in
        _crate.panicking.assert_failed
          kind
          (deref left_val)
          (deref right_val)
          _crate.option.Option.None ;;
        tt
      else
        tt
    end ;;
    self.value.
  
  Definition unwrap_or (self : CtOption<T>) (def : T) : T :=
    ImplT.conditional_select def self.value self.is_some.
  
  Definition unwrap_or_else (self : CtOption<T>) (f : F) : T :=
    ImplT.conditional_select (f tt) self.value self.is_some.
  
  Definition is_some (self : static_ref CtOption<T>) : Choice :=
    self.is_some.
  
  Definition is_none (self : static_ref CtOption<T>) : Choice :=
    not self.is_some.
  
  Definition map (self : CtOption<T>) (f : F) : CtOption :=
    ImplCtOption.new
      (f (ImplT.conditional_select (ImplT.default tt) self.value self.is_some))
      self.is_some.
  
  Definition and_then (self : CtOption<T>) (f : F) : CtOption :=
    let tmp := f
      (ImplT.conditional_select (ImplT.default tt) self.value self.is_some) in
    assign tmp.is_some := bit_and tmp.is_some self.is_some ;;
    tmp.
  
  Definition or_else (self : CtOption<T>) (f : F) : CtOption :=
    let is_none := is_none self in
    let f := f tt in
    ImplSelf.conditional_select self f is_none.
End ImplCtOption.
(* End impl [CtOption] *)

Module Impl_ConditionallySelectable_for_CtOption.
  Definition Self := CtOption.
  
  #[global] Instance I : ConditionallySelectable.Class Self := {|
    conditional_select
      (a : static_ref CtOption<T>)
      (b : static_ref CtOption<T>)
      (choice : Choice)
      :=
      ImplCtOption.new
        (ImplT.conditional_select a.value b.value choice)
        (ImplChoice.conditional_select a.is_some b.is_some choice);
  |}.
Module ImplCtOption.

Module Impl_ConstantTimeEq_for_CtOption.
  Definition Self := CtOption.
  
  #[global] Instance I : ConstantTimeEq.Class Self := {|
    ct_eq
      (self : static_ref CtOption<T>)
      (rhs : static_ref CtOption)
      :=
      let a := is_some self in
      let b := is_some rhs in
      bit_or
        (bit_and (bit_and a b) (ct_eq self.value rhs.value))
        (bit_and (not a) (not b));
  |}.
Module ImplCtOption.

Class ConstantTimeGreater : Set := {
  ct_gt : static_ref Self -> static_ref Self -> Choice;
}.

Module Impl_ConstantTimeGreater_for_u8.
  Definition Self := u8.
  
  #[global] Instance I : ConstantTimeGreater.Class Self := {|
    ct_gt
      (self : static_ref u8)
      (other : static_ref u8)
      :=
      let gtb := bit_and self (not other) in
      let ltb := bit_and (not self) other in
      let pow := 1 in
      loop (if lt pow 8 then
        assign ltb := bit_or ltb (shr ltb pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      let bit := bit_and gtb (not ltb) in
      let pow := 1 in
      loop (if lt pow 8 then
        assign bit := bit_or bit (shr bit pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      ImplChoice.from (bit_and bit 1);
  |}.
Module Implu8.

Module Impl_ConstantTimeGreater_for_u16.
  Definition Self := u16.
  
  #[global] Instance I : ConstantTimeGreater.Class Self := {|
    ct_gt
      (self : static_ref u16)
      (other : static_ref u16)
      :=
      let gtb := bit_and self (not other) in
      let ltb := bit_and (not self) other in
      let pow := 1 in
      loop (if lt pow 16 then
        assign ltb := bit_or ltb (shr ltb pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      let bit := bit_and gtb (not ltb) in
      let pow := 1 in
      loop (if lt pow 16 then
        assign bit := bit_or bit (shr bit pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      ImplChoice.from (bit_and bit 1);
  |}.
Module Implu16.

Module Impl_ConstantTimeGreater_for_u32.
  Definition Self := u32.
  
  #[global] Instance I : ConstantTimeGreater.Class Self := {|
    ct_gt
      (self : static_ref u32)
      (other : static_ref u32)
      :=
      let gtb := bit_and self (not other) in
      let ltb := bit_and (not self) other in
      let pow := 1 in
      loop (if lt pow 32 then
        assign ltb := bit_or ltb (shr ltb pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      let bit := bit_and gtb (not ltb) in
      let pow := 1 in
      loop (if lt pow 32 then
        assign bit := bit_or bit (shr bit pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      ImplChoice.from (bit_and bit 1);
  |}.
Module Implu32.

Module Impl_ConstantTimeGreater_for_u64.
  Definition Self := u64.
  
  #[global] Instance I : ConstantTimeGreater.Class Self := {|
    ct_gt
      (self : static_ref u64)
      (other : static_ref u64)
      :=
      let gtb := bit_and self (not other) in
      let ltb := bit_and (not self) other in
      let pow := 1 in
      loop (if lt pow 64 then
        assign ltb := bit_or ltb (shr ltb pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      let bit := bit_and gtb (not ltb) in
      let pow := 1 in
      loop (if lt pow 64 then
        assign bit := bit_or bit (shr bit pow) ;;
        assign pow := add pow pow ;;
        tt
      else
        Break ;;
        tt) from while ;;
      ImplChoice.from (bit_and bit 1);
  |}.
Module Implu64.

Class ConstantTimeLess : Set := {
  ct_lt : static_ref Self -> static_ref Self -> Choice;
}.

Module Impl_ConstantTimeLess_for_u8.
  Definition Self := u8.
  
  #[global] Instance I : ConstantTimeLess.Class Self := {|
  |}.
Module Implu8.

Module Impl_ConstantTimeLess_for_u16.
  Definition Self := u16.
  
  #[global] Instance I : ConstantTimeLess.Class Self := {|
  |}.
Module Implu16.

Module Impl_ConstantTimeLess_for_u32.
  Definition Self := u32.
  
  #[global] Instance I : ConstantTimeLess.Class Self := {|
  |}.
Module Implu32.

Module Impl_ConstantTimeLess_for_u64.
  Definition Self := u64.
  
  #[global] Instance I : ConstantTimeLess.Class Self := {|
  |}.
Module Implu64.
