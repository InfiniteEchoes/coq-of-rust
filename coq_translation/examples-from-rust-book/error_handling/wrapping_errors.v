(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module error := std.error.

Module Error := std.error.Error.

Module fmt := std.fmt.

Module ParseIntError := std.num.ParseIntError.

Error TyAlias.

Error Enum.

Module Impl__crate_fmt_Debug_for_DoubleError.
  Definition Self := DoubleError.
  
  Global Instance I : _crate.fmt.Debug.Class Self := {|
    _crate.fmt.Debug.fmt
        (self : ref DoubleError)
        (f : mut_ref _crate.fmt.Formatter) :=
      match self with
      | DoubleError.EmptyVec => _crate.fmt.ImplFormatter.write_str f "EmptyVec"
      | DoubleError.Parse (__self_0) =>
        _crate.fmt.ImplFormatter.debug_tuple_field1_finish f "Parse" __self_0
      end;
  |}.
Module ImplDoubleError.

Module Impl_fmt_Display_for_DoubleError.
  Definition Self := DoubleError.
  
  Global Instance I : fmt.Display.Class Self := {|
    fmt.Display.fmt (self : ref DoubleError) (f : mut_ref fmt.Formatter) :=
      match deref self with
      | DoubleError.EmptyVec =>
        method
          "write_fmt"
          f
          (_crate.fmt.ImplArguments.new_v1
            [ "please use a vector with at least one element" ]
            [  ])
      | DoubleError.Parse () =>
        method
          "write_fmt"
          f
          (_crate.fmt.ImplArguments.new_v1
            [ "the provided string could not be parsed as int" ]
            [  ])
      end;
  |}.
Module ImplDoubleError.

Module Impl_error_Error_for_DoubleError.
  Definition Self := DoubleError.
  
  Global Instance I : error.Error.Class Self := {|
    error.Error.source (self : ref DoubleError) :=
      match deref self with
      | DoubleError.EmptyVec => None
      | DoubleError.Parse (e) => Some e
      end;
  |}.
Module ImplDoubleError.

Module Impl_From_for_DoubleError.
  Definition Self := DoubleError.
  
  Global Instance I : From.Class ParseIntError Self := {|
    From.from (err : ParseIntError) := DoubleError.Parse err;
  |}.
Module ImplDoubleError.

Definition double_first (vec : Vec) : Result :=
  let first :=
    match branch (method "ok_or" (method "first" vec) DoubleError.EmptyVec) with
    | {| Break.0 := residual; |} => Return (from_residual residual)
    | {| Continue.0 := val; |} => val
    end in
  let parsed :=
    match branch (method "parse" first) with
    | {| Break.0 := residual; |} => Return (from_residual residual)
    | {| Continue.0 := val; |} => val
    end in
  Ok (mul 2 parsed).

Definition print (result : Result) : unit :=
  match result with
  | Ok (n) =>
    _crate.io._print
      (_crate.fmt.ImplArguments.new_v1
        [ "The first doubled is "; "\n" ]
        [ _crate.fmt.ImplArgumentV1.new_display n ]) ;;
    tt
  | Err (e) =>
    _crate.io._print
      (_crate.fmt.ImplArguments.new_v1
        [ "Error: "; "\n" ]
        [ _crate.fmt.ImplArgumentV1.new_display e ]) ;;
    tt ;;
    if let_if Some (source) := method "source" e then
      _crate.io._print
        (_crate.fmt.ImplArguments.new_v1
          [ "  Caused by: "; "\n" ]
          [ _crate.fmt.ImplArgumentV1.new_display source ]) ;;
      tt ;;
      tt
    else
      tt
  end.

Definition main (_ : unit) : unit :=
  let numbers := ComplexTypePath.into_vec [ "42"; "93"; "18" ] in
  let empty := _crate.vec.ImplVec.new tt in
  let strings := ComplexTypePath.into_vec [ "tofu"; "93"; "18" ] in
  print (double_first numbers) ;;
  print (double_first empty) ;;
  print (double_first strings) ;;
  tt.
