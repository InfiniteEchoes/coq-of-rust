(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module fs := std.fs.

Module File := std.fs.File.
Definition File := File.t.

Module OpenOptions := std.fs.OpenOptions.
Definition OpenOptions := OpenOptions.t.

Module io := std.io.

Import std.io.prelude.

Module unix := std.os.unix.

Module Path := std.path.Path.
Definition Path := Path.t.

Definition cat (path : ref Path) : io.Result :=
  let f :=
    match branch (ImplFile.open path) with
    | Break {| Break.0 := residual; |} => Return (from_residual residual)
    | Continue {| Continue.0 := val; |} => val
    end in
  let s := ImplString.new tt in
  match method "read_to_string" f s with
  | Ok (_) => Ok s
  | Err (e) => Err e
  end.

Definition echo (s : ref str) (path : ref Path) : io.Result :=
  let f :=
    match branch (ImplFile.create path) with
    | Break {| Break.0 := residual; |} => Return (from_residual residual)
    | Continue {| Continue.0 := val; |} => val
    end in
  method "write_all" f (method "as_bytes" s).

Definition touch (path : ref Path) : io.Result :=
  match
    method
      "open"
      (method "write" (method "create" (ImplOpenOptions.new tt) true) true)
      path
  with
  | Ok (_) => Ok ()
  | Err (e) => Err e
  end.

Definition main (_ : unit) : unit :=
  _crate.io._print (_crate.fmt.ImplArguments.new_v1 [ "`mkdir a`\n" ] [  ]) ;;
  tt ;;
  match fs.create_dir "a" with
  | Err (why) =>
    _crate.io._print
      (_crate.fmt.ImplArguments.new_v1
        [ "! "; "\n" ]
        [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
    tt
  | Ok (_) => tt
  end ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`echo hello > a/b.txt`\n" ] [  ]) ;;
  tt ;;
  method
    "unwrap_or_else"
    (echo "hello" (ImplPath.new "a/b.txt"))
    (fun why =>
      _crate.io._print
        (_crate.fmt.ImplArguments.new_v1
          [ "! "; "\n" ]
          [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
      tt ;;
      tt) ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`mkdir -p a/c/d`\n" ] [  ]) ;;
  tt ;;
  method
    "unwrap_or_else"
    (fs.create_dir_all "a/c/d")
    (fun why =>
      _crate.io._print
        (_crate.fmt.ImplArguments.new_v1
          [ "! "; "\n" ]
          [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
      tt ;;
      tt) ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`touch a/c/e.txt`\n" ] [  ]) ;;
  tt ;;
  method
    "unwrap_or_else"
    (touch (ImplPath.new "a/c/e.txt"))
    (fun why =>
      _crate.io._print
        (_crate.fmt.ImplArguments.new_v1
          [ "! "; "\n" ]
          [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
      tt ;;
      tt) ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`ln -s ../b.txt a/c/b.txt`\n" ] [  ]) ;;
  tt ;;
  if true then
    method
      "unwrap_or_else"
      (unix.fs.symlink "../b.txt" "a/c/b.txt")
      (fun why =>
        _crate.io._print
          (_crate.fmt.ImplArguments.new_v1
            [ "! "; "\n" ]
            [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
        tt ;;
        tt) ;;
    tt
  else
    tt ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`cat a/c/b.txt`\n" ] [  ]) ;;
  tt ;;
  match cat (ImplPath.new "a/c/b.txt") with
  | Err (why) =>
    _crate.io._print
      (_crate.fmt.ImplArguments.new_v1
        [ "! "; "\n" ]
        [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
    tt
  | Ok (s) =>
    _crate.io._print
      (_crate.fmt.ImplArguments.new_v1
        [ "> "; "\n" ]
        [ _crate.fmt.ImplArgumentV1.new_display s ]) ;;
    tt
  end ;;
  _crate.io._print (_crate.fmt.ImplArguments.new_v1 [ "`ls a`\n" ] [  ]) ;;
  tt ;;
  match fs.read_dir "a" with
  | Err (why) =>
    _crate.io._print
      (_crate.fmt.ImplArguments.new_v1
        [ "! "; "\n" ]
        [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
    tt
  | Ok (paths) =>
    match into_iter paths with
    | iter =>
      loop
        match next iter with
        | None => Break
        | Some {| Some.0 := path; |} =>
          _crate.io._print
            (_crate.fmt.ImplArguments.new_v1
              [ "> "; "\n" ]
              [
                _crate.fmt.ImplArgumentV1.new_debug
                  (method "path" (method "unwrap" path))
              ]) ;;
          tt ;;
          tt
        end ;;
        tt
        from
        for
    end
  end ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`rm a/c/e.txt`\n" ] [  ]) ;;
  tt ;;
  method
    "unwrap_or_else"
    (fs.remove_file "a/c/e.txt")
    (fun why =>
      _crate.io._print
        (_crate.fmt.ImplArguments.new_v1
          [ "! "; "\n" ]
          [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
      tt ;;
      tt) ;;
  _crate.io._print
    (_crate.fmt.ImplArguments.new_v1 [ "`rmdir a/c/d`\n" ] [  ]) ;;
  tt ;;
  method
    "unwrap_or_else"
    (fs.remove_dir "a/c/d")
    (fun why =>
      _crate.io._print
        (_crate.fmt.ImplArguments.new_v1
          [ "! "; "\n" ]
          [ _crate.fmt.ImplArgumentV1.new_debug (method "kind" why) ]) ;;
      tt ;;
      tt) ;;
  tt.
